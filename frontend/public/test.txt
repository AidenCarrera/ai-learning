Object-Oriented Programming and Data Abstraction
Control or PROCESS abstraction is a very old idea (subroutines!), though few languages provide it in a truly general form (Scheme comes close).
Data abstraction is somewhat newer, though its roots can be found in Simula67.
An Abstract Data Type (ADT) is one that is defined in terms of the operations that it supports rather than in terms of its structure or implementation.
Why abstractions?
Easier to think about - hide what doesn't matter to programmer.
Protection - prevent access to things you shouldn't see.
Plug compatibility - replacement of pieces, often without recompilation, definitely without rewriting libraries.
Division of labor in software projects.
Historical Development of Abstraction Mechanisms
Recall that we traced the historical development of abstraction mechanisms:
Static set of variables (Basic)
Locals (Fortran)
Statics (Fortran, Algol 60, C)
Modules (Modula-2, Ada 83)
Module types (Euclid)
Objects (Smalltalk, C++, Eiffel, Java, Oberon, Modula-3, Ada 95)
Statics allow a subroutine to retain values from one invocation to the next, while hiding the name in-between.
Modules allow a collection of subroutines to share some statics, still with hiding.
If you want to build an abstract data type, though, you have to make the module a manager.
Module types allow the module to be the abstract data type - you can declare a bunch of them.
This is generally more intuitive.
It avoids explicit object parameters to many operations.
One minor drawback: If you have an operation that needs to look at the innards of two different types, you'd define both types in the same manager module in Modula-2.
In C++ you need to make one of the classes (or some of its members) "friends" of the other class.
Objects add inheritance and dynamic method binding.
Simula 67 introduced these, but didn't have data hiding.
The 3 key factors in OO programming:
Encapsulation (data hiding)
Inheritance
Dynamic method binding
Encapsulation and Inheritance Details (C++)
Visibility rules govern Public and Private parts of an object declaration/definition.
There are 2 reasons to put things in the declaration:
So programmers can get at them (if public).
So the compiler can understand them (At the very least the compiler needs to know the size of an object, even though the programmer isn't allowed to get at many or most of the private fields).
That's why private fields must be in declaration.
C++ distinguishes among:
public class members: accessible to anybody.
protected class members: accessible to members of this or derived classes.
private: accessible just to members of this class.
A C++ structure (struct) is simply a class whose members are public by default.
C++ base classes can also be public, private, or protected.